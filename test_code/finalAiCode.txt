#include "wordlist.h"
#include "YourProjectName_inference.h" // <-- CHANGE THIS

// --- Pin Definition (same) ---
#define BUTTON_PIN 14

// --- Timings are now only for gaps, not for dot/dash length ---
#define LETTER_GAP 750  // You can adjust this gap
#define WORD_GAP 1750   // You can adjust this gap

// --- Morse Code Dictionary (same) ---
const char* morse_code[] = {".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."};
const char morse_chars[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";

String current_sequence = "";
String translated_text = "";
String predicted_chars = "";
unsigned long press_time = 0;
unsigned long release_time = 0;
unsigned long last_input_time = 0;

// Variable to hold the duration for the classifier
static float latest_press_duration = 0;

// Helper function required by Edge Impulse library
int get_feature_data(size_t offset, size_t length, float *out_ptr) {
    (void)offset;
    (void)length;
    *out_ptr = latest_press_duration;
    return 0;
}

void setup() {
  Serial.begin(115200);
  pinMode(BUTTON_PIN, INPUT);
  Serial.println("AI Morse Translator Ready!");
  Serial.println("--------------------------");
}

void loop() {
  if (digitalRead(BUTTON_PIN) == HIGH) {
    if (press_time == 0) {
      press_time = millis();
      if (press_time - last_input_time > LETTER_GAP && current_sequence != "") {
        translateSequence();
      }
    }
  } else {
    if (press_time != 0) {
      release_time = millis();
      latest_press_duration = (float)(release_time - press_time);

      // --- AI Inference ---
      signal_t signal;
      signal.total_length = 1;
      signal.get_data = &get_feature_data;
      ei_impulse_result_t result = {0};
      run_classifier(&signal, &result, false);

      // Find the top prediction
      String prediction = "";
      float confidence = 0.0;
      for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
          if (result.classification[ix].value > confidence) {
              confidence = result.classification[ix].value;
              prediction = result.classification[ix].label;
          }
      }
      
      // Add to sequence based on AI prediction
      if (prediction == "dot") {
        current_sequence += ".";
      } else if (prediction == "dash") {
        current_sequence += "-";
      }
      
      last_input_time = millis();
      press_time = 0;
      updateSerialMonitor();
    }
  }

  // Gap detection logic remains the same
  if (millis() - last_input_time > WORD_GAP && current_sequence != "") {
    translateSequence();
    translated_text += " ";
    updateSerialMonitor();
  } else if (millis() - last_input_time > LETTER_GAP && current_sequence != "" && press_time == 0) {
    translateSequence();
  }
}

// All helper functions (updatePredictions, translateSequence, updateSerialMonitor) are identical to Phase 2.
// Paste the functions from the Phase 2 code block here.
void updatePredictions() {
  predicted_chars = "";
  if (translated_text.length() == 0) return;
  int last_space = translated_text.lastIndexOf(' ');
  String current_word = (last_space == -1) ? translated_text : translated_text.substring(last_space + 1);
  if (current_word.length() == 0) { updateSerialMonitor(); return; }
  for (int i = 0; i < WORD_LIST_SIZE; i++) {
    String word_from_list = String(word_list[i]);
    if (word_from_list.startsWith(current_word) && word_from_list.length() > current_word.length()) {
      char next_char = word_from_list.charAt(current_word.length());
      if (predicted_chars.indexOf(next_char) == -1) { predicted_chars += next_char; }
    }
  }
  updateSerialMonitor();
}

void translateSequence() {
  bool found = false;
  for (int i = 0; i < 26; i++) {
    if (current_sequence.equals(morse_code[i])) {
      translated_text += morse_chars[i];
      found = true;
      break;
    }
  }
  if (!found) { translated_text += "?"; }
  current_sequence = "";
  updatePredictions();
}

void updateSerialMonitor() {
  Serial.print("\r                                                                          \r");
  Serial.print("Text: " + translated_text);
  Serial.print(" | Current: " + current_sequence);
  Serial.print(" | Predicts: " + predicted_chars);
}